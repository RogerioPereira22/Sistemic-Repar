"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSubmissionCollection = void 0;
var sendEmail_1 = __importDefault(require("./hooks/sendEmail"));
var createCharge_1 = __importDefault(require("./hooks/createCharge"));
// all settings can be overridden by the config
var generateSubmissionCollection = function (formConfig) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    var newConfig = __assign(__assign({}, (formConfig === null || formConfig === void 0 ? void 0 : formConfig.formSubmissionOverrides) || {}), { slug: ((_a = formConfig === null || formConfig === void 0 ? void 0 : formConfig.formSubmissionOverrides) === null || _a === void 0 ? void 0 : _a.slug) || 'form-submissions', access: __assign({ create: function () { return true; }, update: function () { return false; }, read: function (_a) {
                var user = _a.req.user;
                return !!user;
            } }, ((_b = formConfig === null || formConfig === void 0 ? void 0 : formConfig.formSubmissionOverrides) === null || _b === void 0 ? void 0 : _b.access) || {}), admin: __assign(__assign({}, ((_c = formConfig === null || formConfig === void 0 ? void 0 : formConfig.formSubmissionOverrides) === null || _c === void 0 ? void 0 : _c.admin) || {}), { enableRichTextRelationship: false }), hooks: __assign({ beforeChange: __spreadArray([
                function (data) { return (0, createCharge_1.default)(data, formConfig); },
                function (data) { return (0, sendEmail_1.default)(data, formConfig); }
            ], ((_e = (_d = formConfig === null || formConfig === void 0 ? void 0 : formConfig.formSubmissionOverrides) === null || _d === void 0 ? void 0 : _d.hooks) === null || _e === void 0 ? void 0 : _e.beforeChange) || [], true) }, ((_f = formConfig === null || formConfig === void 0 ? void 0 : formConfig.formSubmissionOverrides) === null || _f === void 0 ? void 0 : _f.hooks) || {}), fields: __spreadArray([
            {
                name: 'form',
                type: 'relationship',
                relationTo: ((_g = formConfig === null || formConfig === void 0 ? void 0 : formConfig.formOverrides) === null || _g === void 0 ? void 0 : _g.slug) || 'forms',
                required: true,
                admin: {
                    readOnly: true
                },
            },
            {
                name: 'submissionData',
                type: 'array',
                admin: {
                    readOnly: true
                },
                fields: [
                    {
                        name: 'field',
                        type: 'text',
                        required: true,
                    },
                    {
                        name: 'value',
                        type: 'text',
                        required: true,
                        validate: function (value) {
                            // TODO:
                            // create a validation function that dynamically
                            // relies on the field type and its options as configured.
                            // How to access sibling data from this field?
                            // Need the `name` of the field in order to validate it.
                            // Might not be possible to use this validation function.
                            // Instead, might need to do all validation in a `beforeValidate` collection hook.
                            if (typeof value !== 'undefined') {
                                return true;
                            }
                            return 'This field is required.';
                        },
                    },
                ],
            }
        ], ((_h = formConfig === null || formConfig === void 0 ? void 0 : formConfig.formSubmissionOverrides) === null || _h === void 0 ? void 0 : _h.fields) || [], true) });
    var paymentFieldConfig = (_j = formConfig === null || formConfig === void 0 ? void 0 : formConfig.fields) === null || _j === void 0 ? void 0 : _j.payment;
    if (paymentFieldConfig) {
        newConfig.fields.push({
            name: 'payment',
            type: 'group',
            admin: {
                readOnly: true
            },
            fields: [
                {
                    name: 'field',
                    label: 'Field',
                    type: 'text'
                },
                {
                    name: 'status',
                    label: 'Status',
                    type: 'text'
                },
                {
                    name: 'amount',
                    type: 'number',
                    admin: {
                        description: 'Amount in cents'
                    }
                },
                {
                    name: 'paymentProcessor',
                    type: 'text',
                },
                {
                    name: 'creditCard',
                    label: 'Credit Card',
                    type: 'group',
                    fields: [
                        {
                            name: 'token',
                            label: 'token',
                            type: 'text'
                        },
                        {
                            name: 'brand',
                            label: 'Brand',
                            type: 'text'
                        },
                        {
                            name: 'number',
                            label: 'Number',
                            type: 'text'
                        }
                    ]
                }
            ]
        });
    }
    return newConfig;
};
exports.generateSubmissionCollection = generateSubmissionCollection;
//# sourceMappingURL=index.js.map